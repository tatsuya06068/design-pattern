# デザインパターンとは

デザインパターンとは特定のコードではなく特定の問題を解決するための一般的な概念です。

デザインパターンには下記の説明がされています

- パターンの意図 : 問題と解決策の両方を簡単に説明。
- 動機 : 問題とパターンが達成する解決策をさらに説明。
- クラスの構造 : パターンの各部分と部分間の関係を説明。
- 普及しているプログラミング言語の一つによるコード例により、 パターンの背後にあるアイディアの理解を容易にする。

## デザインパターンを学ぶ理由

デザインパターンは、 ソフトウェア設計における一般的な問題に対する実証済み、 テスト済み解決策の道具箱です。
パターンを知ることであらゆる種類の問題を解決する方法を知れます。

デザインパターンは、 チーム内でより効率的にコミュニケーションを取るための共通言語を定義します。


## デザインパターンの分類

- 生成に関するパターン : 柔軟性を増し、 コードの再利用を促すようなオブジェクト生成の仕組みを提供します。
- 構造に関するパターンは : 構造の柔軟性と効率を維持しつつ、 オブジェクトとクラスを大きな構造に束ねる方法を説明します。
- 振る舞いに関するパターンは : アルゴリズムやオブジェクト間の責任の分担に関するものです。


## 生成に関するパターン

### Factory Method


スーパークラスでオブジェクトを作成するためのインターフェースが決まっています。 
しかし、 サブクラスでは作成されるオブジェクトの型を変更することができます。

**問題**
物流管理アプリケーションを作成するとします。
アプリの最初のバージョンは、トラック輸送のみを処理できます。 
コードの大部分は Truckクラス内に存在します。

このアプリに海上物流を組み込む要件が追加にが必要になった場合、大部分がTruckクラスに結合されているためアプリに Ships （船） を追加するには、 コードの大部分に手を入れる必要があります。

結果として、 運輸オブジェクトのクラスに応じてアプリの動作を切り替える条件文だらけの、 かなり厄介なコードができてしまうでしょう。

```go
type Truck struct{}

// 運ぶ処理
func (t *Truck) PlanDelivery(){
    ~~~ 処理 ~~~
    t.createTransport()
}

// 積み込み処理
func (t *Truck) createTransport(){ 
    ~~~ 処理 ~~~
}


type Ship struct{}

// 運ぶ処理
func (s *Ship) Carrey(){
    ~~~ 処理 ~~~
}


func main(transportMethod string){
    if transportMethod == 'SHIP'{
        shipInstance.Carrey()
    }elseif(transportMethod == 'Truck'){
        truckInstance.Carrey()
    }
    retrun
}

```

**解決策**

Factory Method パターンに従うと、 new 演算子(GOで言う必要なメソッドを持った構造体の呼び出し)を使用した直接のオブジェクト作成呼び出しを、 特別なファクトリー・メソッドへの呼び出しで置き換えます。

ファクトリーメソッドから返されるオブジェクトはプロダクトと呼ばれます。

```go

type ITransport interface{
    func Order(){}
    func Delivery(){}
}

// --------------------------------------------------
type SeaTransport struct {}

func(sl SeaTransport) Order(){}
func(sl SeaTransport) Delivery(){}

func NewSeaTransport()ITransport{
    return SeaTransport{}
}

// --------------------------------------------------


// --------------------------------------------------
type RoadTransport struct {}


func(sl RoadTransport) Order(){}
func(sl RoadTransport) Delivery(){}

func NewRoadTransport()ITransport{
    return RoadTransport{}
}
// --------------------------------------------------

// ファクトリー
// --------------------------------------------------
func TransportFactory(transportMethod string) (ITransport, error) {
    if transportMethod == "SHIP" {
        return NewSeaTransport(), nil
    }
    if transportMethod == "Truck" {
        return NewRoadTransport(), nil
    }
    return nil, fmt.Errorf("Wrong  transport method passed")
}
// --------------------------------------------------

// クライアントコード
// --------------------------------------------------
func main(){
    Transport, err := TransportFactory('SHIP')
}

func flow(transport ITransport){
    transport.Order()
    transport.Delivery()
}
// --------------------------------------------------
```

コンストラクターの呼び出しをプログラムのある部分から別の部分に移動しただけです。 しかし、 これにより、 サブクラスのファクトリー・メソッドを上書きさえすれば作成されるプロダクトのクラスの変更が可能というメリットがあります。

これらのプロダクトに共通のベースクラスまたはインターフェースがある場合にのみ、 サブクラスは、 異なる型のプロダクトを返すことができ、 ファクトリー・メソッドの戻り値の型はインタフェースとして宣言することで制限をつけることができています。

上記の処理にしておくことで

ファクトリー・メソッドを使用するコード （クライアントコードとよく呼ばれる） からは、 様々なサブクラスが返す実際のプロダクトの間に違いは見られません。 クライアントはすべての製品を抽象的な Transport として扱います。 クライアントは、 すべての Transport オブジェクトが deliver メソッドを持っていることは知っていますが、 それが厳密にどのように振る舞うかは、 クライアントにとっては重要なことではありません。


## 構造に関するパターン




## 振る舞いに関するパターン